# acausal [![stable](http://badges.github.io/stability-badges/dist/stable.svg)](http://github.com/badges/stability-badges)

[![npm version](https://badge.fury.io/js/acausal.svg)](https://badge.fury.io/js/acausal) [![GitHub version](https://badge.fury.io/gh/abrisene%2Facausal.svg)](https://badge.fury.io/gh/abrisene%2Facausal) [![Build Status](https://travis-ci.com/abrisene/acausal.svg?branch=main)](https://travis-ci.com/abrisene/acausal) [![Coverage Status](https://coveralls.io/repos/github/abrisene/acausal/badge.svg?branch=feature/typescript)](https://coveralls.io/github/abrisene/acausal?branch=feature/typescript)


## Markov Chains

- [_acausal_ Home](https://abrisene.github.io/acausal/)
- [Random Distribution Quickstart](https://abrisene.github.io/acausal/readme/distribution.md)

A **Markov Chain** is a mathematical model of a system in which the future state of the system depends only on its present state.

Markov Chains are usually generated by building a statistical model off of sample data, such as a list of names, which can then be used to output sequences which resemble the sampled data. A useful property of this process is that sample data can be "mixed" together like paint to achieve a desired result.

For example, if you wanted to generate names which sounded like a mix of Irish and Japanese, you could generate a Markov Chain from a sample of Irish and Japanese names and the resulting model would be able to output names that mixed the two.

**Markov Chain Quickstart Example - Name Generator:**
```typescript
import { MarkovChain } from 'acausal';

// Sample Data
const jpNames = ['honoka', 'akari', 'himari', 'mei', 'ema'];
const ieNames = ['grace', 'fiadh', 'emily', 'sophie', 'ava'];
const names = [...jpNames, ...ieNames];

// Prepare Data Source - the class expects an array of arrays.
const src = names.map(name => name.split(''));

/* Should result in:
[
  [ 'h', 'o', 'n', 'o', 'k', 'a' ],
  [ 'a', 'k', 'a', 'r', 'i' ],
  [ 'h', 'i', 'm', 'a', 'r', 'i' ],
  [ 'm', 'e', 'i' ],
  [ 'e', 'm', 'a' ],
  [ 'g', 'r', 'a', 'c', 'e' ],
  [ 'f', 'i', 'a', 'd', 'h' ],
  [ 'e', 'm', 'i', 'l', 'y' ],
  [ 's', 'o', 'p', 'h', 'i', 'e' ],
  [ 'a', 'v', 'a' ]
]
*/

// Create the Markov Chain from the source data.
const chain = new MarkovChain({
  seed: 33,       // Random Seed - if this is empty it will be generated.
  maxOrder: 2,    // Maximum Order - Chain will generate orders up to this value.
  sequences: src, // Source data, expects an array of arrays.
});

// Generate 5 picks.
for (let i = 0; i < 3; i += 1) {
  const pick = chain.generate({
    min: 4,       // Min Picks - This will force the model to pick at least 4 times.
    max: 10,      // Max Picks - Stops generation after 10 picks if no end has been reached.
    order: 2,     // Order - The largest gram size used to calculate the next pick.
    strict: false // Strict Order - Dynamically adjusts order up or down each pick if false.
  });
  console.log(pick.join(''));
}

/* Should print:

    sophimari
    emari
    hie

*/
```

### Core Concepts

#### States and Dependent Probability

#### Order and Grams

### How to use Markov Chains

In this example we'll create a Markov Chain that predicts the the weather for a given day depending on the previous day's weather.

#### Data Preparation

We'll start by creating sample data consisting of weekly sequences of daily weather summaries.

Each state will represent a type of weather, including:

- Sunny
- Cloudy
- Rainy
- Stormy

```typescript
// Import the necessary classes
import { Distribution, Random } from 'acausal';

/*
  Format the source data as an array of arrays where each array represents a sequence of states.
  - In this case, each state represents the observed weather in a day.
  - If we were building a name generator each state might be a letter in a given name.
*/
const src = [
  ['sunny', 'sunny', 'sunny', 'cloudy', 'cloudy', 'sunny', 'sunny'],
  ['sunny', 'cloudy', 'cloudy', 'cloudy', 'cloudy', 'rainy', 'cloudy'],
];
```

#### Creation

##### Instanced Workflow
```typescript
// Create a new Markov Chain instance
const weather = new MarkovChain({
  seed: 5,
  sequences: src,
  maxOrder: 2,
});

// Create a clone of the instance
const weatherClone = weather.clone();

// We can serialize the Markov Chain in the following ways:
let weatherData;

weatherData = weather.serialize();
weatherData = weather.model;
weatherData = weather.dto;
```

##### Functional Workflow

```typescript
// Create a new Markov Chain instance
let weatherData = MarkovChain.new({
  seed: 5,
  sequences: src,
  maxOrder: 2,
});

// Create a clone of the instance
const weatherClone = MarkovChain.clone(weatherData);
```

#### Updating

Here we'll add sequences, which will update the probabilities of transitioning from one state to another in our Markov Chain.

We can also *insert* sequences.

By default, sequences a have start and end states prepended and appended. This allows the Markov Chain to determine which states to pick from a cold start, and where it should naturally end a generated sequence.

Insertion allows us to explicitly define where we want to add our sequences.
There are three types of insertion:

- `'middle'` inserts sequences without any start or end state.
- `'start'` inserts sequences with a start state, but no end state.
- `'end'` inserts sequences with an end state, but no start state.

This is useful if we want to manipulate the probability of a sequence
without affecting the probability of transitioning to or from the start
and end states.

For example in the current data:
- The only possible start and end states are 'cloudy' and 'sunny'
- A 'stormy' day must be preceded and followed by a 'rainy' day.

##### Instanced Workflow

```typescript
// Add a new sequence.
weather.addSequence(['sunny', 'cloudy', 'cloudy', 'cloudy', 'cloudy', 'rainy', 'cloudy']);

// Add multiple sequences.
weather.addSequence([
  ['cloudy', 'rainy', 'rainy', 'stormy', 'rainy', 'cloudy', 'cloudy'],
  ['cloudy', 'rainy', 'stormy', 'rainy', 'rainy', 'cloudy', 'sunny'],
]);

// Insert a sequence that lets 'stormy' days to be followed by 'cloudy' days.
// Inserting 'middle' will make sure that we don't start on 'stormy', or affect
// the likelihood of ending on 'cloudy'.
weather.addSequence(['stormy', 'cloudy'], 'middle');

// Insert a sequence that lets us start on a 'rainy' day.
// Inserting 'start' will allow us to start on 'rainy', but won't affect the likelihood
// of ending on this state.
weather.addSequence(['rainy'], 'start');

// Insert a sequence that lets us end on a 'stormy' day.
// Insterting 'end' will allow us to end on 'stormy', but won't affect the likelihood
// of starting on this state.
weather.addSequence(['stormy'], 'end');
```

##### Functional Workflow

```typescript
// Add a new sequence.
weatherData = MarkovChain.addSequence(weatherData, ['sunny', 'cloudy', 'cloudy', 'cloudy', 'cloudy', 'rainy', 'cloudy']);

// Add multiple sequences.
weatherData = MarkovChain.addSequences(
  weatherData,
  [
    ['cloudy', 'rainy', 'rainy', 'stormy', 'rainy', 'cloudy', 'cloudy'],
    ['cloudy', 'rainy', 'stormy', 'rainy', 'rainy', 'cloudy', 'sunny'],
  ]
);

/*
  We can also *insert* sequences.

  By default, sequences a have start and end states prepended and appended.
  This allows the Markov Chain to determine which states to pick from a cold start,
  and where it should naturally end a generated sequence.

  Insertion allows us to explicitly define where we want to add our sequences.
  There are three types of insertion:

  - 'middle' inserts sequences without any start or end state.
  - 'start' inserts sequences with a start state, but no end state.
  - 'end' inserts sequences with an end state, but no start state.

  This is useful if we want to manipulate the probability of a sequence
  without affecting the probability of transitioning to or from the start
  and end states.

  For example in the current data:
  - The only possible start and end states are 'cloudy' and 'sunny'
  - A 'stormy' day must be preceded and followed by a 'rainy' day.
*/

// Insert a sequence that lets 'stormy' days to be followed by 'cloudy' days.
// Inserting 'middle' will make sure that we don't start on 'stormy', or affect
// the likelihood of ending on 'cloudy'.
weatherData = MarkovChain.addSequence(weatherData, ['stormy', 'cloudy'], 'middle');

// Insert a sequence that lets us start on a 'rainy' day.
// Inserting 'start' will allow us to start on 'rainy', but won't affect the likelihood
// of ending on this state.
weatherData = MarkovChain.addSequence(weatherData, ['rainy'], 'start');

// Insert a sequence that lets us end on a 'stormy' day.
// Insterting 'end' will allow us to end on 'stormy', but won't affect the likelihood
// of starting on this state.
weatherData = MarkovChain.addSequence(weatherData, ['stormy'], 'end');
```

#### Generation


##### Instanced Workflow

###### Single Picks

```typescript

// Pick a random next state from the start.
const p1a = weather.pick();
// => 'rainy'

// Pick a random previous state from the end.
const p1b = weather.pick(false, false);
//    'cloudy' <=

// Pick the next state starting from a 'cloudy' day.
const p1c = weather.pick(['cloudy']);
// => 'sunny'

// Pick the next state starting from a 'stormy' day, excluding 'cloudy'.
const p1d = weather.pick(['stormy'], true, ['cloudy']);
// => 'rainy'

// Pick the next state after a two 'rainy' days in a row.
const p1e = weather.pick(['rainy', 'rainy']);
// => 'cloudy'

// Alias for picking a next state after a stormy day.
const p1f = weather.next(['stormy']);
// => 'cloudy'

// Alias for picking a previous state prior to a stormy day.
const p1g = weather.last(['stormy']);
//    'rainy' <=
```

###### Sequence Generation

```typescript
// Generate weather for at least 3 days
const s1a = weather.generate({
  order: 1,
  min: 3,
});
// => [ 'cloudy', 'sunny', 'cloudy', 'sunny', 'sunny' ]

// Generate weather for at most 5 days.
const s1b = weather.generate({
  order: 1,
  max: 5,
});
// => [ 'sunny', 'cloudy', 'cloudy', 'sunny', 'sunny' ]

// Generate weather for exactly 5 days starting on 'sunny'.
const s1c = weather.generate({
  order: 1,
  min: 5,
  max: 5,
  start: ['sunny'],
});
// => ['sunny', 'cloudy', 'cloudy', 'sunny', 'sunny']

// Generate weather for exactly 5 days, but don't allow 'sunny' or 'cloudy' weather.
const s1d = weather.generate({
  order: 1,
  min: 5,
  max: 5,
  mask: ['sunny', 'cloudy'],
});
// => [ 'rainy', 'rainy', 'rainy', 'stormy', 'rainy' ]

// Generate weather for the PREVIOUS 4 days if today's weather is 'stormy'
const s1e = weather.generate({
  order: 1,
  min: 4,
  max: 4,
  start: ['stormy'],
  direction: 'last',
});
//    [ 'rainy', 'stormy', 'rainy', 'stormy' ] <=
```

##### Functional Workflow

###### Single Picks

```typescript
// If we want seeded results, we need to create a new random number generator,
// however this is not necessary - an RNG will be created automatically if none is defined.
const rng = new Random({ seed: 5 });

// Pick a random next state from the start.
const p1a = MarkovChain.pick(weatherData, undefined, undefined, undefined, rng);
// => 'rainy'

// Pick a random previous state from the end.
const p1b = MarkovChain.pick(weatherData, false, false, undefined, rng);
//    'cloudy' <=

// Pick the next state starting from a 'cloudy' day.
const p1c = MarkovChain.pick(weatherData, ['cloudy'], undefined, undefined, rng);
// => 'sunny'

// Pick the next state starting from a 'stormy' day, excluding 'cloudy'.
const p1d = MarkovChain.pick(weatherData, ['stormy'], true, ['cloudy'], rng);
// => 'rainy'

// Pick the next state after a two 'rainy' days in a row.
const p1e = MarkovChain.pick(weatherData, ['rainy', 'rainy'], undefined, undefined, rng);
// => 'cloudy'

// Alias for picking a next state after a stormy day.
const p1f = MarkovChain.next(weatherData, ['stormy'], undefined, rng);
// => 'cloudy'

// Alias for picking a previous state prior to a stormy day.
const p1g = MarkovChain.last(weatherData, ['stormy'], undefined, rng);
//   'rainy' <=
```

###### Sequence Generation

```typescript
// Generate weather for at least 3 days
const s1a = MarkovChain.generate({
  model: weatherData,
  engine: rng,
  order: 1,
  min: 3,
});
// => [ 'cloudy', 'sunny', 'cloudy', 'sunny', 'sunny' ]

// Generate weather for at most 5 days.
const s1b = MarkovChain.generate({
  model: weatherData,
  engine: rng,
  order: 1,
  max: 5,
});
// => [ 'sunny', 'cloudy', 'cloudy', 'sunny', 'sunny' ]

// Generate weather for exactly 5 days starting on 'sunny'.
const s1c = MarkovChain.generate({
  model: weatherData,
  engine: rng,
  order: 1,
  min: 5,
  max: 5,
  start: ['sunny'],
});
// => ['sunny', 'cloudy', 'cloudy', 'sunny', 'sunny']

// Generate weather for exactly 5 days, but don't allow 'sunny' or 'cloudy' weather.
const s1d = MarkovChain.generate({
  model: weatherData,
  engine: rng,
  order: 1,
  min: 5,
  max: 5,
  mask: ['sunny', 'cloudy'],
});
// => [ 'rainy', 'rainy', 'rainy', 'stormy', 'rainy' ]

// Generate weather for the PREVIOUS 4 days if today's weather is 'stormy'
const s1e = MarkovChain.generate({
  model: weatherData,
  engine: rng,
  order: 1,
  min: 4,
  max: 4,
  start: ['stormy'],
  direction: 'last',
});
//    [ 'rainy', 'stormy', 'rainy', 'stormy' ] <=
```

## Extended Markov API Documentation
For more documentation of underlying functions, please see the [Markov Chain class documentation](https://abrisene.github.io/acausal/modules/structures_markov.html).

## Next: [Home](https://abrisene.github.io/acausal/readme.md)
